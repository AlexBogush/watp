# Специализации языков
Я имел счастье программировать на очень разных языках. В университете я изучал как классические всем знакомые языки с объектно ориентированной парадигмой, так и языки с так называемой функциональной парадигмой, языки строго или нестрого типизированные, или вообще не типизированные, языки, подразумевающие многопоточность или цикл событий, языки логические и так далее. Самое смешное, что я находил после такого разнообразного опыта - это споры программистов о том, какой язык или группа языков лучше. Так как языки программирования и их многобразие являются крайне важной темой в картине мира, которая излагается в этой книге, мы остановимся на них поподробнее.

Дело в том, что для программиста, получившего классическое образование, изучавшего методы трансляции (компиляция, интерпретация, о которых мы говорили в предыдущих главах) и писавего свои собственные трансляторы, которые перегоняют созданный тобой язык программирования в какой-то другой, уже известный компьютеру язык, очевидно, что первичен не язык, а задача. Даже электронные вычислительные машины в целом были придуманы не потому что это круто, а потому что возникали задачи, для которых они были нужны. И тогда сначала делались механические машины, помогающие решать интеллектуальные задачи и крайне специализированные под эти задачи (например, деревянные счеты для вычислений в десятичной системе счисления), а потом эти же принципы применялись и к электронным вычислительным машинам. Пришлось пройти долгий путь обобщения задач, приведения задач к одному виду, трансляции описания задач, чтобы в итоге одна и та же вычислительная машина, пользующаяся наиболее универсальными методами, могла решать множество разных классов задач. Это и есть современные компьютеры. Кстати, как мы обсуждали ранее, этот процесс в какой-то мере пошел вспять, ведь в современных процессорах есть не только отделы для общих задач, но и крайне специализированные участки чипов.

Но суть остается прежней: язык - это, в первую очередь, средство описания задачи. Чем проще в данном языке описывается задача, тем проще и быстрее находится решение для этой задачи. Поэтому, повторюсь, язык создается под задачу или класс задач. Критерий применимости языка - это простота описания задачи в этом языке. Все настолько просто. Спорить о том, какой язык лучше - это все равно, что спорить, что лучше - топор или молоток. Есть старая шутка: у еврея спрашивают, сколько будет 2+2, а он отвечает вопросом "мы покупаем или продаем?". Он поступает абсолютно корректно, интересуясь более крупной задачей перед тем, как решать одну ее составную часть. После нескольких примеров мы придем к забавному выводу, о котором вы, скорее всего, уже догадываетесь. Примеры нужны не для того, чтобы вы поняли, а для того, чтобы вы прочувствовали.

## Эркюль Пуаро в кармане
Сталкивались ли вы когда-нибудь со сложной ситуацией? Обычно она характеризовалась тем, что существовал некий набор фактов, условий, домыслов, выводов, гипотез и так далее. Чтобы разобраться в таких ситуациях, с каждым полученным кусочком информации нужно было совершить несколько действий:
1. Выделить факты, отделить их от мнений. Большинство людей просто предпочитают этого не делать. Одно только это умение, помноженное на хоть какое-то образование, позволит вам устроиться на работу с хорошим окладом и спокойно жить.
2. Выделить условия/законы. Для большинства людей это в принципе за гранью возможностей. Мы склонны воспринимать на веру подаваемые нам условия и законы, но никак не выделять или хотя бы проверять их самостоятельно.
3. Выстроить систему условий и фактов, и в ее рамки пытаться встроить гипотезы, проверив, не ломает ли это логической картины. Как говаривал Шерлок Холмс, отбросьте все действительно невозможное, и то, что останется, будет правдой, каким бы невероятным оно ни казалось.

Так вот, есть специальный язык программирования, на котром можно очень легко и кратко описать описать факты и условия, а потом задать вопрос или проверить гипотезу. Этот язык создавался как средство проверки математических гипотез, и, соответственно, проверки доказательств математических теорем. Это было его основной специализацией, так как математика строится по этим правилам: из нескольких аксиом, которые не доказываются, выстраивается огромная красивая логическая картина из определений, свойств и теорем, которую можно изучать годами.
Этот язык - Prolog. Язык так называемого логического программирования. 

Неопытный программист тут же задаст вопрос - а зачем он нужен, такой язык, если на любом популярном языке программирования можно написать программу, решающую подобные задачи? Ответ простой: задача, описание которой на Прологе займет пару десятков легко читаемых строк, на другом языке займет тысячи строк, в которых даже автор программы не разберется через месяц после написания. Это и есть критерий выбора языка под задачу.

Кстати, преподаватели, излагающие Пролог, отмечают, что этому языку гораздо проще обучить не-программиста, чем программиста. Все потому, что если ты научился пользоваться молотком, все вокруг превращается в гвозди.

Вот пример описания задачи на языке Пролог:
```
старше("Петр", "Иван"). 
старше("Василий", "Тимофей"). 
старше("Тимофей", "Петр").

старше(X, Y) :- старше(X, Z), старше(Z, Y).

? старше("Тимофей", V).
? старше(U, "Петр").
? старше(U, V).
```
Сначала сообщаются факты, кто кого старше
Потом задается условие, что если X старше Z и Z старше Y, то X старше Y

Затем задаются вопросы(проверяются гипотезы):
1. За исключением заданных мной фактов, кого еще старше Тимофей? Ответ: Тимофей старше Ивана
2. За исключением заданных мной фактов, кто еще старше Петра? Ответ: Василий старше Петра
3. Кто в целом старше кого? Ответ: Иван-самый младший; Василий — самый старший; Тимофей старше Петра.

Этот простой пример кажется наивным, ведь мы и сами можем разложить по полочкам, кто кого старше. Но вот вопрос: а если нам известно не 3 факта, а 20? В этом случае придется сесть с листочком бумаги и перебирать варианты, сопоставлять и очень долго пытаться прийти к нужному выводу. Кстати, на листочке бумаги в описании задачи мы изобретем что-то вроде языка Пролог, пытаясь декларативно описать задачу максимально компактным образом. В случае же, если фактов не хватает либо мы не знаем какой-либо закономерности, вы уверены, что вы найдете, какого конкретного первичного факта или закономерности вам не достает? Если описание задачи не позволяет ответить на заданный вопрос, Пролог способен сказать, какой именно факт или закономерность нужно добыть, чтобы найти ответ. Среди людей в сложных ментальных моделях на такое способны только очень тренированные люди, которые занимаются подобными задачами десятки лет. Отличным примером являются детективные романы. Например, когда в романах Агаты Кристи в конце повествования все заинтересованные лица собираются в одной комнате и Эркюль Пуаро неспешно излагает, как именно он пришел к пониманию, что убийца - садовник, все восторженно его слушают. А он всего лишь пронаблюдал факты, сопоставил показания, проверил многоуровневые гипотезы, отбросил все, что создавало противоречия с фактами и четкими законами, и пришел к однозначному выводу. Умея пользоваться Прологом, вы получаете в свое распоряжение карманного Эркюля Пуаро, правда, лишь ту его часть, которая проверяет выкладки. Все-таки наблюдательность и умение разделять факты и показания пока не автоматизировано.

Так почему же язык Пролог так бесит программистов? В основном, из-за своей декларативной направленности. Он прекрасно подходит для того, чтобы описать конкретную задачу, но на нем не всегда удобно или очевидно опиывать бизнес-логику повторяющихся задач, а именно за это и нужно 99% рынка.

Но что же делать, когда мы хотим не разбирать конкретную детективную ситуацию, а подумать о маркетинге, социологии и других похожих задачах? Ведь здесь практически не бывает правил, которые однозначно работают в 100% случаев! Все построено вокруг вероятностей, конверсий, допущений, прикидок, размеров рынка или популяций, а также скрытых параметров и психологии. Что ж, в этом случае просто приходится признать, что здесь нужна другая логика, другая ментальная модель. Что-то подсказывает, что нужна математическая статистика, теория вероятностей, щедро приправленная огромным количеством данных. Однако, чтобы добавить сюда психологию, нужно будет собрать новую ментальную модель, ответвляющуюся от теории вероятностей и математической статистики. Самое интересное то, что бед нужной модели (языка описания) невозможно решить задачу. Но почему?

## Предел сложности
Никогда не удивлялись тому, что человек стал доминировать на планете, несмотря на то, что ни когтей, ни зубов, ни скорости, ни физической силы, большей, чем у крупных хищников, не имел? Конечно, удивлялись, тема-то изъезженная и банальная. Нам все объяснили: нам помогла смекалка и социальность.

У меня есть провокационный вопрос: подозревает ли лев или тигр, явно доминирующий в своей дикой среде, что, оказывается, в знакомом ему мире доминирует далеко не он? Я подозреваю, что не подозревает =) Возможно, заподозрит, находясь в зоопарке, да и то только в том случае, если сможет связать, что его угнетает другое живое существо, а не законы природы.

Я предполагаю, что к мышцам, когтям и зубам можно смело добавить и предел объема и сложности информации, которую мы способны оперативно обрабатывать. Насколько я помню из IQ теста, который я последний раз проходил примерно в 22-23 года, там есть целый класс задач, направленный на определение именно этого проедела у конкретного тестируемого. Надо сказать, что различие этого предела на проценты вовсе не означает пропорциональных различий в сложности решаемых задач. Скорее я бы сказал, что здесь применима аналогия с дальностью прыжка, которая либо позволяет тебе перелететь через пропасть (решить задачу), либо не позволяет. Но даже у человека с крайне высоким IQ это предел есть, и он не так уж и велик.

Именно поэтому мы и строим все новые и новые языки описания, удобные для понимания задач и их решения. Так мы пониммаем переход количества в качество. Человек с высоким пределом сложности создает новый язык описания задачи, основываясь на предыдущем известном ему языке описания. В программировании сказали бы, что он создает транслятор из созданного им языка программирования в известный другим язык программирования. Чем гениальнее открытие, тем радикальнее различается парадигма нового языка от парадигмы языка-основы. Дальше более простые люди могут использовать вновь созданный язык для решения этого класса задач, так как он делает описание и решение более доступным, не требующим высокого предела сложности. Конца и края этому процессу не видно. Также наивно полагать, что существует некая модель, способная описать все, что угодно, и при этом помещающаяся в голове человека.


физическая сила




Радужная картинка, не правда ли? (Статистика)